<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Khaitan & Co. - Quiz with KAI Assistant</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Georgia', serif;
        }

        body {
            background: linear-gradient(135deg, #2c3e50 0%, #4a6580 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
            overflow-x: hidden;
        }

        /* General Container Styles */
        .container {
            background-color: white;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            width: 100%;
            max-width: 700px;
            padding: 35px;
            position: relative;
            /* Removed overflow: hidden from here to prevent dropdown clipping */
            z-index: 10;
            text-align: center;
        }

        .header {
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 20px;
            margin-bottom: 25px;
            position: relative;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .firm-name {
            color: #2c3e50;
            font-size: 32px;
            font-weight: bold;
            margin-bottom: 5px;
            letter-spacing: 0.5px;
        }

        .firm-tagline {
            color: #7f8c8d;
            font-size: 16px;
            font-style: italic;
        }

        /* Quiz Styles */
        .quiz-container {
            display: none;
            background-color: white;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            width: 100%;
            max-width: 700px;
            padding: 35px;
            position: relative;
            z-index: 10;
        }

        .score-container {
            background: #f8f9fa;
            padding: 10px 20px;
            border-radius: 20px;
            text-align: center;
        }

        .score-label {
            font-size: 14px;
            color: #7f8c8d;
        }

        .score-value {
            font-size: 24px;
            font-weight: bold;
            color: #3498db;
        }

        .question-number {
            color: #3498db;
            font-size: 20px;
            font-weight: 600;
            margin-bottom: 20px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .question-text {
            color: #2c3e50;
            font-size: 22px;
            font-weight: 600;
            margin-bottom: 30px;
            line-height: 1.4;
            padding-right: 20px;
        }

        .options-container {
            margin-bottom: 30px;
            text-align: left;
        }

        .option {
            display: flex;
            align-items: center;
            padding: 16px 20px;
            margin-bottom: 15px;
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .option:hover {
            border-color: #3498db;
            background-color: #f8f9fa;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.05);
        }

        .option input {
            margin-right: 15px;
            transform: scale(1.2);
        }

        .option label {
            cursor: pointer;
            color: #34495e;
            font-size: 18px;
            flex: 1;
        }

        .feedback {
            background-color: #fff3cd;
            border-left: 5px solid #ffc107;
            padding: 18px;
            margin-bottom: 25px;
            display: flex;
            align-items: center;
            border-radius: 8px;
            animation: fadeIn 0.5s ease;
        }

        .feedback.correct {
            background-color: #d4edda;
            border-left-color: #28a745;
        }

        .feedback-icon {
            font-size: 24px;
            margin-right: 12px;
        }

        .feedback-text {
            color: #856404;
            font-weight: 600;
            font-size: 18px;
        }

        .feedback.correct .feedback-text {
            color: #155724;
        }

        .ai-comment {
            background-color: #e8f4fc;
            border-left: 5px solid #3498db;
            padding: 18px;
            margin-bottom: 25px;
            border-radius: 8px;
            font-style: italic;
            color: #2c3e50;
            font-size: 17px;
            animation: fadeIn 0.7s ease;
        }

        .buttons-container {
            display: flex;
            justify-content: space-between;
            margin-top: 20px;
        }

        .nav-button {
            background: linear-gradient(to right, #3498db, #2c3e50);
            color: white;
            border: none;
            padding: 14px 30px;
            border-radius: 8px;
            font-size: 18px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 10px rgba(52, 152, 219, 0.3);
        }

        .nav-button:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 15px rgba(52, 152, 219, 0.4);
        }

        .nav-button:disabled {
            background: #95a5a6;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        /* KAI Bot Styles */
        .kai-bot {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 150px;
            height: 150px;
            cursor: pointer;
            z-index: 100;
            transition: transform 0.3s ease;
            display: block;
        }
        
        .kai-bot img {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        .kai-bot:hover {
            transform: scale(1.1);
        }

        .kai-chat {
            position: fixed;
            bottom: 170px;
            right: 20px;
            width: 300px;
            background: white;
            border-radius: 15px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.15);
            padding: 15px;
            z-index: 99;
            opacity: 0;
            transform: translateY(20px);
            transition: all 0.5s ease;
        }

        .kai-chat.active {
            opacity: 1;
            transform: translateY(0);
        }

        .kai-chat::after {
            content: '';
            position: absolute;
            bottom: -10px;
            right: 30px;
            width: 20px;
            height: 20px;
            background: white;
            transform: rotate(45deg);
        }

        .chat-text {
            font-size: 16px;
            color: #2c3e50;
            line-height: 1.5;
        }
        
        .progress-container {
            height: 8px;
            background-color: #ecf0f1;
            border-radius: 4px;
            margin-bottom: 25px;
            overflow: hidden;
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(to right, #3498db, #2c3e50);
            border-radius: 4px;
            transition: width 0.3s ease;
        }

        .leaderboard-table {
            width: 100%;
            border-collapse: collapse;
            text-align: left;
            margin-top: 15px;
        }
        .leaderboard-table th, .leaderboard-table td {
            padding: 12px 15px;
            border-bottom: 1px solid #e0e0e0;
        }
        .leaderboard-table th {
            background-color: #3498db;
            color: white;
        }
        .leaderboard-table tr:hover {
            background-color: #f8f9fa;
        }

        /* Drag & Drop Quiz Styles */
        .game-area {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-bottom: 30px; /* Increased bottom margin for better spacing */
        }

        .unsorted-items {
            width: 100%;
            min-height: 150px;
            border: 2px dashed #3498db;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-content: flex-start; /* Items start from the top */
            gap: 10px;
            background-color: #f8f9fa;
        }

        .item {
            background: white;
            padding: 12px 15px;
            border-radius: 6px;
            cursor: grab;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            transition: all 0.2s ease;
            font-size: 14px;
            text-align: center;
            min-width: 120px;
            border: 1px solid #ddd;
        }

        .item:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
        }

        .bin-container {
            display: flex;
            justify-content: space-between;
            width: 100%;
            margin-top: 20px;
        }

        .bin {
            width: 48%;
            min-height: 120px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            padding: 15px;
            text-align: center;
            display: flex;
            flex-direction: column;
        }

        .confidential-bin {
            border-color: #e74c3c;
            background-color: #ffebee;
        }

        .public-bin {
            border-color: #2ecc71;
            background-color: #e8f5e9;
        }

        .bin-title {
            font-weight: bold;
            margin-bottom: 10px;
            color: #2c3e50;
        }

        .bin-content {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            gap: 8px;
            min-height: 60px;
            justify-content: flex-start;
            align-items: center;
        }
        
        .drag-over {
            border-style: solid;
            border-width: 3px;
        }

        .completion-message {
            margin-top: 15px;
            padding: 10px;
            background-color: #d4edda;
            color: #155724;
            border-radius: 5px;
            font-weight: bold;
        }
        
        /* Login Form Styles */
        .login-form {
            margin-top: 20px;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #2c3e50;
        }

        .form-group input {
            width: 100%;
            padding: 12px 15px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 16px;
            transition: border-color 0.3s ease;
        }

        .form-group input:focus {
            border-color: #3498db;
            outline: none;
        }

        /* Common button styles */
        .next-btn, .start-quiz-btn {
            background: linear-gradient(to right, #3498db, #2c3e50);
            color: white;
            border: none;
            padding: 14px 40px;
            border-radius: 8px;
            font-size: 18px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 10px rgba(52, 152, 219, 0.3);
            margin-top: 20px;
        }

        .next-btn:hover, .start-quiz-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 15px rgba(52, 152, 219, 0.4);
        }

        .next-btn:disabled {
            background: #95a5a6;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        /* Media Container Styles */
        .media-container {
            width: 100%;
            max-width: 700px;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: white;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            padding: 35px;
            position: relative;
            overflow: hidden;
        }
        
        #quiz-video {
            width: 100%;
            border-radius: 10px;
            margin-bottom: 20px;
        }
        
        /* === FULL SCREEN STYLES (for game) === */
        .media-container.full-screen {
            max-width: 100%; 
            width: 100vw; 
            height: 100vh; 
            margin: 0; 
            padding: 0; 
            border-radius: 0; 
            box-shadow: none; 
        }
        
        body.full-screen-game {
            justify-content: flex-start;
            align-items: flex-start;
            padding: 0;
        }

        #game-container {
            width: 100%;
            height: 100%; 
            border: none; 
            border-radius: 0; 
            overflow: hidden;
            display: none;
        }
        
        #game-container iframe {
            width: 100%;
            height: 100%;
        }

        .media-container.full-screen .header,
        .media-container.full-screen #skip-game-btn {
            display: none;
        }
        
        /* === MATCH THE FOLLOWING STYLES === */
        .match-container {
            display: flex;
            flex-direction: column;
            gap: 20px;
            margin-bottom: 30px;
        }

        .match-row {
            display: flex;
            align-items: center;
            gap: 10px; 
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            transition: all 0.3s ease;
        }

        .match-row:hover {
            border-color: #3498db;
            background-color: #f8f9fa;
        }

        .match-item {
            flex: 1;
            padding: 10px 15px;
            background-color: #f8f9fa;
            border-radius: 6px;
            font-weight: 600;
            color: #2c3e50;
            font-size: 16px; 
        }

        .match-dropdown {
            flex: 1;
            width: 100%; /* FIX 2: Ensures dropdown respects container width */
            padding: 10px 15px;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            font-size: 16px;
            background-color: white;
            cursor: pointer;
            transition: border-color 0.3s ease;
        }

        .match-dropdown:focus {
            border-color: #3498db;
            outline: none;
        }

        .match-correct {
            border-color: #2ecc71;
            background-color: #e8f5e9;
        }

        .match-incorrect {
            border-color: #e74c3c;
            background-color: #ffebee;
        }

        /* === TRUE/FALSE QUESTION STYLES === */
        .true-false-container {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 30px;
        }

        .true-false-option {
            flex: 1;
            padding: 20px;
            text-align: center;
            border: 3px solid #e0e0e0;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
            font-size: 18px;
        }

        .true-false-option:hover {
            transform: translateY(-3px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }

        .true-option {
            color: #2ecc71;
            border-color: #2ecc71;
        }

        .false-option {
            color: #e74c3c;
            border-color: #e74c3c;
        }

        .true-false-option.selected {
            background-color: #f8f9fa;
            border-width: 4px;
        }

        .true-option.selected {
            background-color: #e8f5e9;
        }

        .false-option.selected {
            background-color: #ffebee;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @media (max-width: 600px) {
            .container {
                padding: 25px;
            }

            .firm-name {
                font-size: 26px;
            }

            .bin-container {
                flex-direction: column;
            }

            .bin {
                width: 100%;
                margin-bottom: 15px;
            }

            .kai-bot {
                width: 100px;
                height: 100px;
                bottom: 15px;
                right: 15px;
                font-size: 16px;
            }

            .kai-chat {
                width: 250px;
                bottom: 125px;
                right: 15px;
            }
            
            #game-container {
                height: 400px;
            }
            
            .match-row {
                flex-direction: column;
                gap: 10px;
            }
            
            .true-false-container {
                flex-direction: column;
                gap: 15px;
            }
        }
    </style>
</head>
<body>
    <div class="container" id="welcome-container">
        <div class="header">
            <div class="firm-name">Khaitan & Co.</div>
            <div class="firm-tagline">Advocates since 1911</div>
        </div>
        <div style="text-align: center;">
            <p style="font-size: 18px; color: #2c3e50; margin-bottom: 20px;">
                Welcome to the Khaitan & Co. Data Security Awareness Quiz.
                <br>This quiz will test your knowledge of firm policies. Good luck!
            </p>
            <button class="next-btn" id="welcome-next-btn">Continue to Registration</button>
        </div>
    </div>

    <div class="container" id="registration-container" style="display: none;">
        <div class="header">
            <div class="firm-name">Khaitan & Co.</div>
            <div class="firm-tagline">Advocates since 1911</div>
        </div>

        <div class="login-form">
            <div class="form-group">
                <label for="user-name">Full Name</label>
                <input type="text" id="user-name" placeholder="Enter your full name">
            </div>

            <div class="form-group">
                <label for="user-department">Department</label>
                <input type="text" id="user-department" placeholder="Enter your department">
            </div>

            <div class="form-group">
                <label for="user-email">Company Email</label>
                <input type="email" id="user-email" placeholder="Enter your company email">
            </div>

            <button class="start-quiz-btn" id="start-quiz-btn">Start Quiz</button>
        </div>
    </div>

    <div class="quiz-container" id="quiz-container">
        <div class="header">
            <div>
                <div class="firm-name">Khaitan & Co.</div>
                <div class="firm-tagline">Advocates since 1911</div>
            </div>
            <div class="score-container">
                <div class="score-label">SCORE</div>
                <div class="score-value" id="score">0/0</div>
            </div>
        </div>

        <div class="progress-container">
            <div class="progress-bar" id="progress-bar" style="width: 0%"></div>
        </div>

        <div class="question-number" id="question-number">QUESTION 1 OF 5</div>

        <div class="question-text" id="question-text"></div>

        <div class="options-container" id="options-container">
            </div>

        <div class="feedback" id="feedback" style="display: none;">
            <span class="feedback-icon"></span>
            <span class="feedback-text"></span>
        </div>

        <div class="ai-comment" id="ai-comment" style="display: none;"></div>

        <div class="buttons-container">
            <button class="nav-button" id="prev-button" disabled>Previous</button>
            <button class="nav-button" id="next-button">Next</button>
        </div>
    </div>
    
    <div class="media-container" id="media-container" style="display: none;">
        <div class="header">
            <div class="firm-name">Khaitan & Co.</div>
            <div class="firm-tagline">Advocates since 1911</div>
        </div>
        <video id="quiz-video" src="Chaos_Realm_Video_Generation.mp4" autoplay loop muted preload="auto"></video>
        <div id="game-container"></div>
        <button class="nav-button" id="skip-game-btn" style="margin-top: 20px;">Skip to Next Question</button>
    </div>

    <div class="kai-bot" id="kai-bot">
        <img src="KAI bot.png" alt="KAI Assistant">
    </div>

    <div class="kai-chat" id="kai-chat">
        <div class="chat-text" id="chat-text">Hello! I'm KAI, your AI assistant. I'm here to help you with the quiz. Just ask me if you have a question!</div>
    </div>

    <script>
        // Set the backend URL dynamically based on the environment
        const backendUrl = 'https://quiz-game-icc3.onrender.com'; // **IMPORTANT: Update this with your actual Render backend URL**
        // In your local environment, you would use:
        // const backendUrl = 'http://localhost:3000';

        // Quiz Data
        const quizQuestions = [{
            type: "mcq",
            question: "What is 'Confidential Data' according to Firm Policy?",
            options: [
                "Information belonging to the Firm",
                "Information belonging to or entrusted to the Firm",
                "Information that is publicly available"
            ],
            correctAnswer: 1,
            feedback: {
                incorrect: "Incorrect! The policy is specific about all information, whether owned by the firm or entrusted to it.",
                aiComment: "My circuits detect disappointment. Remember, our policy covers more than just our own data."
            }
        }, {
            type: "mcq",
            question: "Which of the following is NOT a protected category under firm policy?",
            options: [
                "Client case files",
                "Employee salary information",
                "Publicly available court documents",
                "Partner meeting minutes"
            ],
            correctAnswer: 2,
            feedback: {
                incorrect: "Not quite right! Publicly available documents are not considered confidential under our policy.",
                aiComment: "Public documents are not considered confidential under our policy. Good try!"
            }
        }, {
            type: "mcq",
            question: "How should confidential documents be disposed of?",
            options: [
                "Recycled in blue bins",
                "Shredded using cross-cut shredders",
                "Thrown in regular trash",
                "Donated to local library"
            ],
            correctAnswer: 1,
            feedback: {
                incorrect: "Incorrect disposal method! Confidential documents must be shredded.",
                aiComment: "Confidential documents must be shredded to prevent information leakage. Data security is paramount!"
            }
        }, {
            type: "sort",
            question: "Drag the documents into the correct security bins.",
            items: [{
                text: "Client Contract Draft",
                category: "confidential"
            }, {
                text: "Company Newsletter",
                category: "public"
            }, {
                text: "Employee Salary Data",
                category: "confidential"
            }, {
                text: "Press Release",
                category: "public"
            }]
        }, {
            type: "mcq",
            question: "What is the primary purpose of data encryption?",
            options: [
                "To make data smaller for storage",
                "To scramble data so it can't be read without a key",
                "To organize data for faster access",
                "To share data more easily with clients"
            ],
            correctAnswer: 1,
            feedback: {
                incorrect: "That's not it. Data encryption is about security, not size or organization.",
                aiComment: "Encryption is a critical layer of defense, making data unreadable to unauthorized parties."
            }
        }, {
            type: "mcq",
            question: "When is it acceptable to discuss client matters outside the office?",
            options: [
                "Always, if you're discreet",
                "Only with other firm members",
                "Never under any circumstances",
                "Only in emergency situations"
            ],
            correctAnswer: 2,
            feedback: {
                incorrect: "Not acceptable! Client matters are highly sensitive.",
                aiComment: "Client matters should never be discussed outside secure firm environments. Confidentiality is key to our client relationships."
            }
        }, {
            type: "mcq",
            question: "What should you do if you suspect a data breach?",
            options: [
                "Try to fix it yourself",
                "Ignore it unless it's major",
                "Immediately report to the security officer",
                "Tell your colleagues to be careful"
            ],
            correctAnswer: 2,
            feedback: {
                incorrect: "Incorrect response! All potential breaches must be reported immediately.",
                aiComment: "All potential breaches must be reported immediately to the security officer. Timely action is critical to mitigating damage."
            }
        }, {
            type: "sort",
            question: "Sort the following documents based on their confidentiality level.",
            items: [{
                text: "Merger & Acquisition Plan",
                category: "confidential"
            }, {
                text: "Client List",
                category: "confidential"
            }, {
                text: "Firm's Annual Report",
                category: "public"
            }, {
                text: "Marketing Brochure",
                category: "public"
            }]
        }, {
            type: "mcq",
            question: "How often should you change your password, according to best practices?",
            options: [
                "Once a year",
                "Every 6 months",
                "Never, if it's strong",
                "As often as your IT policy requires"
            ],
            correctAnswer: 3,
            feedback: {
                incorrect: "While regular changes are good, the firm's IT policy is the final guide.",
                aiComment: "Our IT policy dictates password rotation schedules. Always check the official guidelines!"
            }
        }, {
            type: "truefalse",
            question: "All employees must complete data security training annually.",
            correctAnswer: true,
            feedback: {
                incorrect: "Incorrect! Annual data security training is mandatory for all employees.",
                aiComment: "Annual training ensures everyone stays updated on the latest security protocols."
            }
        }, {
            type: "match",
            question: "Match the data security terms with their correct definitions.",
            pairs: [
                {
                    term: "Phishing",
                    definition: "Fraudulent attempt to obtain sensitive information by disguising as a trustworthy entity"
                },
                {
                    term: "Encryption",
                    definition: "Process of converting information into a code to prevent unauthorized access"
                },
                {
                    term: "Two-Factor Authentication",
                    definition: "Security process requiring two different forms of identification"
                },
                {
                    term: "Data Breach",
                    definition: "Incident where information is accessed without authorization"
                }
            ],
            feedback: {
                incorrect: "Some matches are incorrect. Review the definitions carefully.",
                aiComment: "Understanding these terms is crucial for maintaining data security."
            }
        }];

        // Game state
        let userData = {
            name: "",
            department: "",
            email: ""
        };
        let currentQuestion = 0;
        let userScore = 0;
        let userAnswers = new Array(quizQuestions.length).fill(null);
        let gameCompleted = false;
        let shuffledDefinitions = []; // Store the shuffled definitions for match question

        // DOM elements
        const welcomeContainer = document.getElementById('welcome-container');
        const registrationContainer = document.getElementById('registration-container');
        const quizContainer = document.getElementById('quiz-container');
        const mediaContainer = document.getElementById('media-container');
        const welcomeNextBtn = document.getElementById('welcome-next-btn');
        const startQuizBtn = document.getElementById('start-quiz-btn');
        const skipGameBtn = document.getElementById('skip-game-btn');
        const kaiBot = document.getElementById('kai-bot');
        const kaiChat = document.getElementById('kai-chat');
        const chatText = document.getElementById('chat-text');
        const userNameInput = document.getElementById('user-name');
        const userDepartmentInput = document.getElementById('user-department');
        const userEmailInput = document.getElementById('user-email');
        const questionNumberElement = document.getElementById('question-number');
        const questionTextElement = document.getElementById('question-text');
        const optionsContainer = document.getElementById('options-container');
        const feedbackElement = document.getElementById('feedback');
        const aiCommentElement = document.getElementById('ai-comment');
        const nextButton = document.getElementById('next-button');
        const prevButton = document.getElementById('prev-button');
        const scoreElement = document.getElementById('score');
        const progressBar = document.getElementById('progress-bar');
        const quizVideo = document.getElementById('quiz-video');
        const gameContainer = document.getElementById('game-container');
        
        // Global function for the game to call
        window.resumeQuiz = function() {
            gameCompleted = true;
            mediaContainer.style.display = 'none';
            quizContainer.style.display = 'block';
            userAnswers[4] = true; 
            currentQuestion = 5;
            displayQuestion();
            updateProgressBar();
            updateScore();
            // Remove full-screen classes
            document.body.classList.remove('full-screen-game');
            mediaContainer.classList.remove('full-screen');
            document.body.style.overflow = 'auto'; // Restore normal scrolling
        }

        // Initialize the application
        function initializeApp() {
            welcomeNextBtn.addEventListener('click', showRegistrationScreen);
            startQuizBtn.addEventListener('click', startQuiz);
            skipGameBtn.addEventListener('click', skipGame);
            kaiBot.addEventListener('click', toggleKaiChat);
        }

        function skipGame() {
            window.resumeQuiz();
        }

        // Screen navigation and quiz functions
        function showRegistrationScreen() {
            welcomeContainer.style.display = 'none';
            registrationContainer.style.display = 'block';
            showKaiMessage("Please register with your details to start the quiz!");
        }

        function startQuiz() {
            if (!userNameInput.value.trim() || !userDepartmentInput.value.trim() || !userEmailInput.value.trim()) {
                showKaiMessage("Please fill in all fields to continue.");
                return;
            }

            userData = {
                name: userNameInput.value.trim(),
                department: userDepartmentInput.value.trim(),
                email: userEmailInput.value.trim()
            };

            registrationContainer.style.display = 'none';
            quizContainer.style.display = 'block';

            initializeQuiz();
        }

        function initializeQuiz() {
            currentQuestion = 0;
            userScore = 0;
            userAnswers = new Array(quizQuestions.length).fill(null);
            gameCompleted = false;
            displayQuestion();
            updateProgressBar();
            updateScore();
            if (!nextButton.hasAttribute('data-listener-added')) {
                nextButton.addEventListener('click', goToNextQuestion);
                nextButton.setAttribute('data-listener-added', 'true');
            }
            if (!prevButton.hasAttribute('data-listener-added')) {
                prevButton.addEventListener('click', goToPreviousQuestion);
                prevButton.setAttribute('data-listener-added', 'true');
            }
        }
        
        function loadGame() {
            gameContainer.innerHTML = '<iframe src="spaceinvaders.html" width="100%" height="100%" frameborder="0"></iframe>';
        }

        function displayQuestion() {
            const question = quizQuestions[currentQuestion];
            questionNumberElement.textContent = `QUESTION ${currentQuestion + 1} OF ${quizQuestions.length}`;
            questionTextElement.textContent = question.question;
            optionsContainer.innerHTML = '';
            
            feedbackElement.style.display = 'none';
            aiCommentElement.style.display = 'none';
            prevButton.disabled = currentQuestion === 0;

            if (currentQuestion === quizQuestions.length - 1) {
                nextButton.textContent = 'Finish Quiz';
            } else {
                nextButton.textContent = 'Next';
            }

            if (currentQuestion === 4 && !gameCompleted) {
                showGameQuestion();
                return;
            }

            if (question.type === "mcq") {
                question.options.forEach((option, index) => {
                    const optionElement = document.createElement('div');
                    optionElement.className = 'option';
                    const input = document.createElement('input');
                    input.type = 'radio';
                    input.name = 'quiz-option';
                    input.id = `option-${index}`;
                    input.value = index;
                    if (userAnswers[currentQuestion] === index) {
                        input.checked = true;
                    }
                    input.addEventListener('change', () => {
                        selectOption(index);
                    });
                    const label = document.createElement('label');
                    label.htmlFor = `option-${index}`;
                    label.textContent = option;
                    optionElement.appendChild(input);
                    optionElement.appendChild(label);
                    optionsContainer.appendChild(optionElement);

                    if (userAnswers[currentQuestion] === index) {
                        optionElement.style.borderColor = '#3498db';
                        optionElement.style.backgroundColor = '#e8f4fc';
                    }
                });
            } else if (question.type === "sort") {
                const gameArea = document.createElement('div');
                gameArea.className = 'game-area';
                
                const unsortedItems = document.createElement('div');
                unsortedItems.className = 'unsorted-items';
                unsortedItems.id = 'unsorted-items';
                
                const binContainer = document.createElement('div');
                binContainer.className = 'bin-container';

                const confidentialBin = document.createElement('div');
                confidentialBin.className = 'bin confidential-bin';
                confidentialBin.id = 'confidential-bin';
                confidentialBin.dataset.type = 'confidential';
                const confidentialBinContent = document.createElement('div');
                confidentialBinContent.className = 'bin-content';
                confidentialBin.innerHTML = `<div class="bin-title">Confidential</div>`;
                confidentialBin.appendChild(confidentialBinContent);

                const publicBin = document.createElement('div');
                publicBin.className = 'bin public-bin';
                publicBin.id = 'public-bin';
                publicBin.dataset.type = 'public';
                const publicBinContent = document.createElement('div');
                publicBinContent.className = 'bin-content';
                publicBin.innerHTML = `<div class="bin-title">Public</div>`;
                publicBin.appendChild(publicBinContent);

                binContainer.appendChild(confidentialBin);
                binContainer.appendChild(publicBin);
                
                gameArea.appendChild(unsortedItems);
                gameArea.appendChild(binContainer);
                optionsContainer.appendChild(gameArea);

                // Populate items, putting them back in bins if previously sorted
                const savedAnswers = userAnswers[currentQuestion] || {};

                question.items.forEach(itemData => {
                    const item = document.createElement('div');
                    item.className = 'item';
                    item.draggable = true;
                    item.textContent = itemData.text;
                    item.id = 'item-' + itemData.text.replace(/\s/g, '');
                    item.dataset.type = itemData.category;
                    
                    const savedCategory = savedAnswers[itemData.text];

                    if (savedCategory === 'confidential') {
                        confidentialBinContent.appendChild(item);
                    } else if (savedCategory === 'public') {
                        publicBinContent.appendChild(item);
                    } else {
                        unsortedItems.appendChild(item);
                    }
                });
                
                setupDragAndDrop();
            } else if (question.type === "truefalse") {
                const trueFalseContainer = document.createElement('div');
                trueFalseContainer.className = 'true-false-container';
                
                const trueOption = document.createElement('div');
                trueOption.className = 'true-false-option true-option';
                trueOption.textContent = 'TRUE';
                trueOption.addEventListener('click', () => {
                    selectTrueFalse(true);
                    document.querySelectorAll('.true-false-option').forEach(opt => {
                        opt.classList.remove('selected');
                    });
                    trueOption.classList.add('selected');
                });
                
                const falseOption = document.createElement('div');
                falseOption.className = 'true-false-option false-option';
                falseOption.textContent = 'FALSE';
                falseOption.addEventListener('click', () => {
                    selectTrueFalse(false);
                    document.querySelectorAll('.true-false-option').forEach(opt => {
                        opt.classList.remove('selected');
                    });
                    falseOption.classList.add('selected');
                });
                
                if (userAnswers[currentQuestion] === true) {
                    trueOption.classList.add('selected');
                } else if (userAnswers[currentQuestion] === false) {
                    falseOption.classList.add('selected');
                }
                
                trueFalseContainer.appendChild(trueOption);
                trueFalseContainer.appendChild(falseOption);
                optionsContainer.appendChild(trueFalseContainer);
            } else if (question.type === "match") {
                const matchContainer = document.createElement('div');
                matchContainer.className = 'match-container';
                
                // Shuffle definitions for matching if no answers are saved, otherwise use saved shuffle
                if (userAnswers[currentQuestion] === null) {
                    shuffledDefinitions = [...question.pairs].sort(() => Math.random() - 0.5);
                    userAnswers[currentQuestion] = { selections: new Array(question.pairs.length).fill(null), shuffle: shuffledDefinitions.map(p => p.definition) };
                } else if (userAnswers[currentQuestion] && userAnswers[currentQuestion].shuffle) {
                    // Restore shuffle state
                    const shuffle = userAnswers[currentQuestion].shuffle;
                    shuffledDefinitions = shuffle.map(def => question.pairs.find(p => p.definition === def));
                } else {
                    // Fallback re-shuffle if saved data is inconsistent, but this shouldn't happen
                    shuffledDefinitions = [...question.pairs].sort(() => Math.random() - 0.5);
                    userAnswers[currentQuestion] = { selections: new Array(question.pairs.length).fill(null), shuffle: shuffledDefinitions.map(p => p.definition) };
                }

                const currentSelections = userAnswers[currentQuestion].selections;

                question.pairs.forEach((pair, index) => {
                    const matchRow = document.createElement('div');
                    matchRow.className = 'match-row';
                    
                    const termElement = document.createElement('div');
                    termElement.className = 'match-item';
                    termElement.textContent = pair.term;
                    
                    const dropdown = document.createElement('select');
                    dropdown.className = 'match-dropdown';
                    dropdown.id = `match-dropdown-${index}`; 
                    
                    // Add default option
                    const defaultOption = document.createElement('option');
                    defaultOption.value = "";
                    defaultOption.textContent = "Select definition";
                    defaultOption.disabled = true;
                    if (currentSelections[index] === null || currentSelections[index] === "") {
                        defaultOption.selected = true;
                    }
                    dropdown.appendChild(defaultOption);
                    
                    // Add definition options using the shuffled order
                    shuffledDefinitions.forEach((def) => {
                        const option = document.createElement('option');
                        option.value = def.definition;
                        option.textContent = def.definition;
                        dropdown.appendChild(option);
                    });
                    
                    // Set selected value if already answered
                    if (currentSelections[index] !== null) {
                        dropdown.value = currentSelections[index];
                    }
                    
                    dropdown.addEventListener('change', (e) => {
                        // Store the selected definition text as the answer
                        currentSelections[index] = e.target.value;
                        userAnswers[currentQuestion].selections = currentSelections; // Save to state
                        checkMatchCompletion();
                    });
                    
                    matchRow.appendChild(termElement);
                    matchRow.appendChild(dropdown);
                    matchContainer.appendChild(matchRow);
                });
                
                optionsContainer.appendChild(matchContainer);
                
                checkMatchCompletion(true); // Pass true to just check and update UI state
            }
        }
        
        function showGameQuestion() {
            quizContainer.style.display = 'none';
            mediaContainer.style.display = 'flex';
            quizVideo.style.display = 'block';
            
            // Force the video to restart and be muted/loop (already in HTML attributes)
            quizVideo.currentTime = 0; 
            quizVideo.play();

            // Original video to game switch
            setTimeout(() => {
                quizVideo.style.display = 'none';
                gameContainer.style.display = 'flex';
                loadGame();
                
                // Apply the full-screen styles right before the game loads
                document.body.classList.add('full-screen-game');
                mediaContainer.classList.add('full-screen');
            }, 5000); // 5 seconds video playback before game starts
            
        }
        
        function selectOption(optionIndex) {
            document.querySelectorAll('.option').forEach(el => {
                el.style.borderColor = '';
                el.style.backgroundColor = '';
            });
            
            userAnswers[currentQuestion] = optionIndex;
            const isCorrect = optionIndex === quizQuestions[currentQuestion].correctAnswer;
            
            document.querySelector(`input[value='${optionIndex}']`).closest('.option').style.borderColor = '#3498db';
            document.querySelector(`input[value='${optionIndex}']`).closest('.option').style.backgroundColor = '#e8f4fc';

            if (isCorrect) {
                feedbackElement.innerHTML = `<span class="feedback-icon">âœ…</span><span class="feedback-text">Correct!</span>`;
                feedbackElement.className = 'feedback correct';
                aiCommentElement.textContent = "Excellent! You're following firm policy correctly.";
                showKaiMessage("Excellent! You're following firm policy correctly.");
            } else {
                feedbackElement.innerHTML = `<span class="feedback-icon">ðŸš¨</span><span class="feedback-text">Incorrect!</span>`;
                feedbackElement.className = 'feedback';
                aiCommentElement.textContent = quizQuestions[currentQuestion].feedback.aiComment;
                showKaiMessage(quizQuestions[currentQuestion].feedback.aiComment);
            }
            
            feedbackElement.style.display = 'flex';
            aiCommentElement.style.display = 'block';
            updateScore();
        }

        function selectTrueFalse(answer) {
            userAnswers[currentQuestion] = answer;
            const isCorrect = answer === quizQuestions[currentQuestion].correctAnswer;
            
            if (isCorrect) {
                feedbackElement.innerHTML = `<span class="feedback-icon">âœ…</span><span class="feedback-text">Correct!</span>`;
                feedbackElement.className = 'feedback correct';
                aiCommentElement.textContent = "Excellent! You're following firm policy correctly.";
                showKaiMessage("Excellent! You're following firm policy correctly.");
            } else {
                feedbackElement.innerHTML = `<span class="feedback-icon">ðŸš¨</span><span class="feedback-text">Incorrect!</span>`;
                feedbackElement.className = 'feedback';
                aiCommentElement.textContent = quizQuestions[currentQuestion].feedback.aiComment;
                showKaiMessage(quizQuestions[currentQuestion].feedback.aiComment);
            }
            
            feedbackElement.style.display = 'flex';
            aiCommentElement.style.display = 'block';
            updateScore();
        }
        
        /**
         * Checks the completion and correctness for match questions.
         * @param {boolean} justUpdateUI - If true, only updates the UI without forcing general feedback.
         */
        function checkMatchCompletion(justUpdateUI = false) {
            const question = quizQuestions[currentQuestion];
            const dropdowns = document.querySelectorAll('.match-dropdown');
            const currentSelections = userAnswers[currentQuestion].selections;

            let allSelected = !currentSelections.includes(null) && !currentSelections.includes("");
            
            if (allSelected) {
                let isCorrect = true;
                
                dropdowns.forEach((dropdown, index) => {
                    const selectedDefinition = dropdown.value;
                    const correctDefinition = question.pairs[index].definition;
                    
                    if (selectedDefinition === correctDefinition) {
                        dropdown.parentElement.classList.add('match-correct');
                        dropdown.parentElement.classList.remove('match-incorrect');
                    } else {
                        dropdown.parentElement.classList.add('match-incorrect');
                        dropdown.parentElement.classList.remove('match-correct');
                        isCorrect = false;
                    }
                });
                
                if (!justUpdateUI) {
                    if (isCorrect) {
                        feedbackElement.innerHTML = `<span class="feedback-icon">âœ…</span><span class="feedback-text">Correct! All matches are accurate.</span>`;
                        feedbackElement.className = 'feedback correct';
                        aiCommentElement.textContent = "Excellent! You have a great understanding of data security terminology.";
                        showKaiMessage("Excellent! You have a great understanding of data security terminology.");
                    } else {
                        feedbackElement.innerHTML = `<span class="feedback-icon">ðŸš¨</span><span class="feedback-text">Some matches are incorrect. Please review.</span>`;
                        feedbackElement.className = 'feedback';
                        aiCommentElement.textContent = question.feedback.aiComment;
                        showKaiMessage(question.feedback.aiComment);
                    }
                    
                    feedbackElement.style.display = 'flex';
                    aiCommentElement.style.display = 'block';
                }
                updateScore();
                
                return isCorrect;
            }
            
            // Clear feedback if not all items are selected
            if (!justUpdateUI) {
                feedbackElement.style.display = 'none';
                aiCommentElement.style.display = 'none';
            }

            return false;
        }

        function setupDragAndDrop() {
            const items = document.querySelectorAll('.item');
            const bins = document.querySelectorAll('.bin, #unsorted-items'); // Add unsorted area as a drop target
            
            items.forEach(item => {
                item.addEventListener('dragstart', dragStart);
                item.addEventListener('dragend', dragEnd);
            });
            
            bins.forEach(bin => {
                bin.addEventListener('dragover', dragOver);
                bin.addEventListener('dragenter', dragEnter);
                bin.addEventListener('dragleave', dragLeave);
                bin.addEventListener('drop', dropItem);
            });
        }

        function dragStart(e) {
            e.dataTransfer.setData('text/plain', e.target.id);
            e.dataTransfer.effectAllowed = 'move';
            setTimeout(() => {
                e.target.classList.add('dragging');
            }, 0);
        }

        function dragEnd(e) {
            e.target.classList.remove('dragging');
        }

        function dragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
        }
        
        function dragEnter(e) {
            e.preventDefault();
            // Check if the current target is an actual drop target (bin or unsorted area)
            if (e.currentTarget.classList.contains('bin') || e.currentTarget.id === 'unsorted-items') {
                e.currentTarget.classList.add('drag-over');
            }
        }

        function dragLeave(e) {
            // Only remove drag-over if the mouse is moving completely out of the drop zone, 
            // not just moving over a child element.
            if (!e.currentTarget.contains(e.relatedTarget)) {
                e.currentTarget.classList.remove('drag-over');
            }
        }

        function dropItem(e) {
            e.preventDefault();
            e.currentTarget.classList.remove('drag-over');
            
            const itemId = e.dataTransfer.getData('text/plain');
            const draggedItem = document.getElementById(itemId);
            const correctType = draggedItem.dataset.type;
            const targetElement = e.currentTarget;
            const itemText = draggedItem.textContent;

            // Initialize userAnswers object if needed
            if (userAnswers[currentQuestion] === null || typeof userAnswers[currentQuestion] !== 'object' || Array.isArray(userAnswers[currentQuestion])) {
                userAnswers[currentQuestion] = {};
            }

            // Check if dropping into a bin
            if (targetElement.classList.contains('bin')) {
                const targetBinType = targetElement.dataset.type;
                targetElement.querySelector('.bin-content').appendChild(draggedItem);
                userAnswers[currentQuestion][itemText] = targetBinType;

                if (correctType === targetBinType) {
                    showKaiMessage("Correct! That item belongs in this category. âœ…");
                } else {
                    showKaiMessage("Incorrect bin! Please review its classification. âŒ");
                }
            } 
            // Check if dropping back into the unsorted area
            else if (targetElement.id === 'unsorted-items') {
                targetElement.appendChild(draggedItem);
                userAnswers[currentQuestion][itemText] = 'unsorted'; // Mark as explicitly unsorted
                showKaiMessage("Item returned to unsorted area. You must place all items into the bins to proceed.");
            }

            setTimeout(checkSortCompletion, 500);
        }
        
        /**
         * Checks the completion and correctness for sort questions.
         */
        function checkSortCompletion() {
            const question = quizQuestions[currentQuestion];
            const allItems = question.items.length;
            let correctlyPlacedCount = 0;
            let allItemsPlacedInBins = true;

            const currentAnswers = userAnswers[currentQuestion];

            if (currentAnswers === null || typeof currentAnswers !== 'object') {
                return false;
            }

            question.items.forEach(itemData => {
                const itemAnswer = currentAnswers[itemData.text];
                
                // If any item is missing an answer or marked 'unsorted', it hasn't been placed in a bin
                if (!itemAnswer || itemAnswer === 'unsorted') {
                    allItemsPlacedInBins = false;
                }
                
                // Check correctness
                if (itemAnswer === itemData.category) {
                    correctlyPlacedCount++;
                }
            });

            const isCorrect = correctlyPlacedCount === allItems;
            
            // If all items are placed in bins, we can finalize the answer
            if (allItemsPlacedInBins) {
                userAnswers[currentQuestion] = isCorrect; 
            } else {
                 // Otherwise, we keep the detailed object of current placements
                // No change to userAnswers[currentQuestion] object state, just checking the overall status
                // To prevent premature 'answered' state in updateScore:
                updateScore(); 
                return false; 
            }
            
            // Only show final feedback and return true if ALL items are correctly sorted.
            if (isCorrect) {
                feedbackElement.innerHTML = `<span class="feedback-icon">âœ…</span><span class="feedback-text">Correct! All documents are in the right bins.</span>`;
                feedbackElement.className = 'feedback correct';
                aiCommentElement.textContent = "Excellent! You have a great understanding of data classification.";
                showKaiMessage("Excellent! You have a great understanding of data classification.");
            } else {
                feedbackElement.innerHTML = `<span class="feedback-icon">ðŸš¨</span><span class="feedback-text">Incorrect! Please review your sorting.</span>`;
                feedbackElement.className = 'feedback';
                aiCommentElement.textContent = "Please re-examine the items and their categories. Sorting correctly is a key security practice.";
                showKaiMessage("Please re-examine the items and their categories. Sorting correctly is a key security practice.");
            }
            
            feedbackElement.style.display = 'flex';
            aiCommentElement.style.display = 'block';
            updateScore();
            
            return isCorrect;
        }

        function goToNextQuestion() {
            if (currentQuestion === 4 && !gameCompleted) {
                showGameQuestion();
                return;
            }

            const currentQ = quizQuestions[currentQuestion];
            let proceed = false;
            
            if (currentQ.type === "mcq") {
                if (userAnswers[currentQuestion] === null) {
                    showKaiMessage("Please select an answer before proceeding.");
                    return;
                }
                proceed = true;
            } else if (currentQ.type === "sort") {
                // Check if all items have been placed into a bin (regardless of correctness)
                const currentAnswers = userAnswers[currentQuestion];
                let allItemsPlacedInBins = true;

                if (currentAnswers === null || typeof currentAnswers !== 'object' || Array.isArray(currentAnswers)) {
                    allItemsPlacedInBins = false;
                } else {
                    currentQ.items.forEach(itemData => {
                        const itemAnswer = currentAnswers[itemData.text];
                        // An item is considered "not placed" if its answer is missing or explicitly 'unsorted'
                        if (!itemAnswer || itemAnswer === 'unsorted') {
                            allItemsPlacedInBins = false;
                        }
                    });
                }

                if (!allItemsPlacedInBins) {
                    showKaiMessage("Please ensure all documents are placed into a Confidential or Public bin before moving forward.");
                    return;
                }
                
                // Perform the check for correctness to update state and show final feedback
                checkSortCompletion(); 
                
                // Allow proceeding even if the answer is incorrect, as long as it's been attempted (all placed)
                proceed = true; 

            } else if (currentQ.type === "truefalse") {
                if (userAnswers[currentQuestion] === null) {
                    showKaiMessage("Please select True or False before proceeding.");
                    return;
                }
                proceed = true;
            } else if (currentQ.type === "match") {
                let allMatched = userAnswers[currentQuestion] && userAnswers[currentQuestion].selections && !userAnswers[currentQuestion].selections.includes(null) && !userAnswers[currentQuestion].selections.includes("");

                if (!allMatched) {
                    showKaiMessage("Please complete all matches before proceeding.");
                    return;
                }
                
                proceed = checkMatchCompletion();
                // Allow proceeding even if the answer is incorrect, as long as it's been attempted (all matched)
                proceed = true; 
            } else {
                proceed = true;
            }

            if (currentQuestion < quizQuestions.length - 1) {
                currentQuestion++;
                displayQuestion();
                updateProgressBar();
                updateScore();
            } else {
                finishQuiz();
            }
        }

        function goToPreviousQuestion() {
            if (currentQuestion > 0) {
                currentQuestion--;
                displayQuestion();
                updateProgressBar();
                updateScore();
            }
        }

        function updateProgressBar() {
            const progress = ((currentQuestion + 1) / quizQuestions.length) * 100;
            progressBar.style.width = `${progress}%`;
        }

        function updateScore() {
            let answeredCount = 0;
            let correctCount = 0;

            quizQuestions.forEach((question, index) => {
                const answer = userAnswers[index];
                
                if (answer !== null) {
                    answeredCount++;
                    
                    if (question.type === "mcq") {
                        if (answer === question.correctAnswer) {
                            correctCount++;
                        }
                    } else if (question.type === "sort") {
                        // Sort question score only counts if the answer is boolean (meaning fully placed)
                        if (typeof answer === 'boolean' && answer === true) {
                            correctCount++;
                        } else if (typeof answer === 'object') {
                            // If it's still an object, it's considered partially answered but not for full score
                            answeredCount--; 
                        }
                    } else if (question.type === "truefalse") {
                        if (answer === question.correctAnswer) {
                            correctCount++;
                        }
                    } else if (question.type === "match") {
                        // For match questions, check if all selections are correct
                        const selections = answer.selections;
                        let allCorrect = true;
                        
                        if (Array.isArray(selections)) {
                            // Check if all are selected and correct
                            if (selections.includes(null) || selections.includes("")) {
                                allCorrect = false;
                                answeredCount--; // Don't count as answered if incomplete
                            } else {
                                selections.forEach((selectedDefinition, selIndex) => {
                                    const correctDefinition = question.pairs[selIndex].definition;
                                    if (selectedDefinition !== correctDefinition) {
                                        allCorrect = false;
                                    }
                                });
                            }
                            if (allCorrect) correctCount++;
                        } else {
                            answeredCount--; // Not a valid answer format
                        }
                    }
                }
            });

            userScore = correctCount;
            scoreElement.textContent = `${userScore}/${answeredCount}`;
        }

        function finishQuiz() {
            const totalQuestions = quizQuestions.length;
            const percentage = Math.round((userScore / totalQuestions) * 100);
            
            quizContainer.innerHTML = `
                <div class="header">
                    <div class="firm-name">Khaitan & Co.</div>
                    <div class="firm-tagline">Advocates since 1911</div>
                </div>
                
                <div style="text-align: center; padding: 40px 20px;">
                    <h2 style="color: #2c3e50; margin-bottom: 20px;">Quiz Completed!</h2>
                    
                    <div style="background: linear-gradient(135deg, #3498db, #2c3e50); color: white; padding: 30px; border-radius: 15px; margin: 20px 0;">
                        <h3 style="font-size: 24px; margin-bottom: 10px;">Final Score</h3>
                        <div style="font-size: 48px; font-weight: bold;">${userScore}/${totalQuestions}</div>
                        <div style="font-size: 20px; margin-top: 10px;">${percentage}%</div>
                    </div>
                    
                    <div style="margin: 30px 0;">
                        <h3 style="color: #2c3e50; margin-bottom: 15px;">Performance Summary</h3>
                        <p style="font-size: 18px; color: #7f8c8d; line-height: 1.6;">
                            ${getPerformanceMessage(percentage)}
                        </p>
                    </div>
                    
                    <div style="background: #f8f9fa; padding: 20px; border-radius: 10px; margin: 20px 0;">
                        <h4 style="color: #2c3e50; margin-bottom: 15px;">Participant Details</h4>
                        <p><strong>Name:</strong> ${userData.name}</p>
                        <p><strong>Department:</strong> ${userData.department}</p>
                        <p><strong>Email:</strong> ${userData.email}</p>
                    </div>
                    
                    <div class="buttons-container" style="justify-content: center; gap: 15px;">
                        <button class="nav-button" id="restart-quiz-btn">Take Quiz Again</button>
                        <button class="nav-button" id="view-leaderboard-btn">View Leaderboard</button>
                    </div>
                </div>
            `;

            document.getElementById('restart-quiz-btn').addEventListener('click', restartQuiz);
            document.getElementById('view-leaderboard-btn').addEventListener('click', showLeaderboard);
            
            showKaiMessage(getKaiCompletionMessage(percentage));
            saveQuizResults(userScore);
        }

        function getPerformanceMessage(percentage) {
            if (percentage >= 90) return "Outstanding! You have excellent knowledge of our data security policies.";
            if (percentage >= 80) return "Very good! You demonstrate strong understanding of security protocols.";
            if (percentage >= 70) return "Good effort! You have a solid foundation in data security.";
            if (percentage >= 60) return "Satisfactory. Consider reviewing the security policies again.";
            return "Please review the data security policies and retake the quiz.";
        }

        function getKaiCompletionMessage(percentage) {
            if (percentage >= 90) return "Wow! You're a data security expert! ðŸŽ‰";
            if (percentage >= 80) return "Excellent work! You really know your stuff! ðŸ‘";
            if (percentage >= 70) return "Great job! You're well on your way to becoming a security pro! ðŸ’ª";
            if (percentage >= 60) return "Good effort! Keep learning and you'll master this! ðŸ“š";
            return "Don't worry! Learning is a process. I'm here to help you improve! ðŸ¤–";
        }

        function restartQuiz() {
            location.reload();
        }

        async function saveQuizResults(score) {
            try {
                const response = await fetch(`${backendUrl}/api/quiz-results`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        name: userData.name,
                        department: userData.department,
                        email: userData.email,
                        score: score,
                        totalQuestions: quizQuestions.length
                    })
                });

                if (response.ok) {
                    const result = await response.json();
                    console.log('Quiz results saved successfully!', result);
                } else {
                    console.error('Failed to save quiz results:', response.statusText);
                }
            } catch (error) {
                console.error('Error saving quiz results:', error);
            }
        }
        
        async function showLeaderboard() {
            try {
                const response = await fetch(`${backendUrl}/api/leaderboard`);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const leaderboard = await response.json();

                let leaderboardHTML = `
                    <div style="margin-top: 20px; background: #f8f9fa; padding: 15px; border-radius: 10px;">
                        <h3 style="text-align: center; color: #2c3e50; margin-bottom: 15px;">ðŸ† Leaderboard ðŸ†</h3>
                        <table class="leaderboard-table">
                            <thead>
                                <tr>
                                    <th>Rank</th>
                                    <th>Name</th>
                                    <th>Department</th>
                                    <th>Score</th>
                                </tr>
                            </thead>
                            <tbody>
                `;
                
                leaderboard.forEach((user, index) => {
                    leaderboardHTML += `
                        <tr>
                            <td>${index + 1}</td>
                            <td>${user.name}</td>
                            <td>${user.department}</td>
                            <td>${user.score}/${user.totalQuestions}</td>
                        </tr>
                    `;
                });
                
                leaderboardHTML += `
                            </tbody>
                        </table>
                    </div>
                `;
                
                const quizContent = document.querySelector('.quiz-container');
                quizContent.innerHTML = leaderboardHTML;
                
                const restartButton = document.createElement('button');
                restartButton.textContent = 'Take Quiz Again';
                restartButton.className = 'nav-button';
                restartButton.style.marginTop = '20px';
                restartButton.addEventListener('click', restartQuiz);
                
                quizContent.appendChild(restartButton);

            } catch (error) {
                console.error('Error fetching leaderboard:', error);
                const quizContent = document.querySelector('.quiz-container');
                quizContent.innerHTML = `
                    <div style="text-align: center; color: #e74c3c; margin: 20px 0;">
                        Failed to load leaderboard. Please ensure the backend server is running correctly.<br>Error: ${error.message}
                    </div>
                    <button class="nav-button" onclick="restartQuiz()">Take Quiz Again</button>
                `;
            }
        }

        function showKaiMessage(message) {
            chatText.textContent = message;
            kaiChat.classList.add('active');
            setTimeout(() => {
                kaiChat.classList.remove('active');
            }, 5000);
        }

        function toggleKaiChat() {
            kaiChat.classList.toggle('active');
            if (kaiChat.classList.contains('active')) {
                const currentQ = quizQuestions[currentQuestion];
                if (userAnswers[currentQuestion] === null) {
                    chatText.textContent = "I'm here to help! Select an answer and I'll give you feedback.";
                } else if (currentQ.type === "mcq" && userAnswers[currentQuestion] === currentQ.correctAnswer) {
                    chatText.textContent = "Excellent! You're following firm policy correctly.";
                } else if (currentQ.type === "truefalse" && userAnswers[currentQuestion] === currentQ.correctAnswer) {
                    chatText.textContent = "Excellent! You're following firm policy correctly.";
                } else {
                    chatText.textContent = currentQ.feedback.aiComment;
                }
            }
        }
        
        function addKeyboardAccessibility() {
            document.addEventListener('keydown', (e) => {
                if (e.key >= '1' && e.key <= '9' && quizContainer.style.display === 'block') {
                    const optionIndex = parseInt(e.key) - 1;
                    const currentQ = quizQuestions[currentQuestion];
                    
                    if (currentQ.type === "mcq" && optionIndex < currentQ.options.length) {
                        selectOption(optionIndex);
                        const optionInput = document.querySelector(`input[value='${optionIndex}']`);
                        if (optionInput) {
                            optionInput.focus();
                        }
                    }
                }
            });
        }

        document.addEventListener('DOMContentLoaded', () => {
            initializeApp();
            addKeyboardAccessibility();
        });
    </script>
</body>
</html>

